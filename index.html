<!DOCTYPE html>
<html lang="en">
  <head>
    <meta name="google-site-verification" content="YJTk-UC700SFkJW8m6RDeThRSbxtom0eST6va5FR64E" />
    <meta charset="UTF-8" />
    <link rel="icon" type="image/png" href="/logo.png" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>SolanaMinter - Create and Mint Your Own Meme Tokens on Solana</title>
    <meta name="description" content="SolanaMinter allows you to create and mint your own meme tokens on the Solana blockchain. Join the meme revolution!" />
    <meta name="keywords" content="Solana, mint, meme tokens, cryptocurrency, blockchain" />
    <link rel="canonical" href="https://yourdomain.com" />

    <!-- Preload critical resources with crossorigin attribute -->
    <link rel="preload" href="/logo.png" as="image" crossorigin="anonymous" />
    <link rel="preload" href="data:application/octet-stream;base64,aW1wb3J0ICIuL3BvbHlmaWxscyI7IC8vIEltcG9ydCBwb2x5ZmlsbHMgZmlyc3QKaW1wb3J0IFJlYWN0IGZyb20gInJlYWN0IjsKaW1wb3J0IFJlYWN0RE9NIGZyb20gInJlYWN0LWRvbS9jbGllbnQiOwppbXBvcnQgeyBCcm93c2VyUm91dGVyIH0gZnJvbSAicmVhY3Qtcm91dGVyLWRvbSI7CmltcG9ydCBBcHAgZnJvbSAiLi9BcHAiOwppbXBvcnQgIi4vaW5kZXguY3NzIjsKaW1wb3J0IHsgU3BlZWRJbnNpZ2h0cyB9IGZyb20gIkB2ZXJjZWwvc3BlZWQtaW5zaWdodHMvcmVhY3QiOwppbXBvcnQgeyBBbmFseXRpY3MgfSBmcm9tICJAdmVyY2VsL2FuYWx5dGljcy9yZWFjdCI7CgpSZWFjdERPTS5jcmVhdGVSb290KGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCJyb290IikhKS5yZW5kZXIoCiAgPFJlYWN0LlN0cmljdE1vZGU+CiAgICA8QnJvd3NlclJvdXRlcj4KICAgICAgPEFwcCAvPgogICAgICA8U3BlZWRJbnNpZ2h0cyAvPgogICAgICA8QW5hbHl0aWNzIC8+CiAgICA8L0Jyb3dzZXJSb3V0ZXI+CiAgPC9SZWFjdC5TdHJpY3RNb2RlPgopOw==" as="script" crossorigin="anonymous" />
    <link rel="preload" href="https://cdn.gpteng.co/gptengineer.js" as="script" crossorigin="anonymous" />

    <!-- Open Graph Meta Tags -->
    <meta property="og:title" content="SolanaMinter - Create and Mint Your Own Meme Tokens" />
    <meta property="og:description" content="Join SolanaMinter to create and mint your own meme tokens on the Solana blockchain." />
    <meta property="og:type" content="website" />
    <meta property="og:image" content="/og-image.png" />
    <meta property="og:url" content="https://yourdomain.com" />

    <!-- Twitter Meta Tags -->
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="SolanaMinter - Create and Mint Your Own Meme Tokens" />
    <meta name="twitter:description" content="Join SolanaMinter to create and mint your own meme tokens on the Solana blockchain." />
    <meta name="twitter:image" content="/og-image.png" />

    <!-- Structured Data -->
    <script type="application/ld+json">
      {
        "@context": "https://schema.org",
        "@type": "WebSite",
        "name": "SolanaMinter",
        "url": "https://yourdomain.com",
        "description": "Create and mint your own meme tokens on Solana.",
        "potentialAction": {
          "@type": "SearchAction",
          "target": "https://yourdomain.com/search?q={search_term_string}",
          "query-input": "required name=search_term_string"
        }
      }
    </script>

    <style>
      /* High-performance base styles */
      html, body {
        margin: 0;
        padding: 0;
        background: hsl(var(--background));
        min-height: 100vh;
        overflow-x: hidden;
        will-change: transform;
        transform: translate3d(0, 0, 0);
        -webkit-transform: translate3d(0, 0, 0);
        backface-visibility: hidden;
        -webkit-backface-visibility: hidden;
        perspective: 1000px;
        -webkit-perspective: 1000px;
        contain: layout style paint;
        isolation: isolate;
      }

      body {
        font-family: system-ui, -apple-system, sans-serif;
        scroll-behavior: smooth;
        opacity: 0;
        animation: fadeIn 0.1s ease-out forwards;
        will-change: opacity;
        transform: translate3d(0, 0, 0);
        -webkit-transform: translate3d(0, 0, 0);
        backface-visibility: hidden;
        -webkit-backface-visibility: hidden;
        contain: layout style paint;
        isolation: isolate;
      }

      /* High-performance animations */
      @keyframes fadeIn {
        to { opacity: 1; }
      }

      #root {
        position: relative !important;
        min-height: 100vh;
        display: flex;
        flex-direction: column;
        transform: translate3d(0, 0, 0);
        -webkit-transform: translate3d(0, 0, 0);
        backface-visibility: hidden;
        -webkit-backface-visibility: hidden;
        perspective: 1000px;
        -webkit-perspective: 1000px;
        contain: layout style paint;
        isolation: isolate;
      }

      /* Optimized loading animation */
      .loading {
        position: fixed;
        inset: 0;
        background: hsl(var(--background));
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 9999;
        will-change: opacity;
        transform: translate3d(0, 0, 0);
        -webkit-transform: translate3d(0, 0, 0);
        backface-visibility: hidden;
        -webkit-backface-visibility: hidden;
        contain: layout style paint;
        isolation: isolate;
      }

      .loader {
        width: 24px;
        height: 24px;
        border-radius: 50%;
        position: relative;
        background: conic-gradient(from 0deg, transparent 0%, #9945FF 100%);
        mask: radial-gradient(circle at center, transparent 55%, white 55%);
        -webkit-mask: radial-gradient(circle at center, transparent 55%, white 55%);
        animation: rotate 0.6s linear infinite;
        will-change: transform;
        transform: translate3d(0, 0, 0);
        -webkit-transform: translate3d(0, 0, 0);
        backface-visibility: hidden;
        -webkit-backface-visibility: hidden;
        contain: layout style paint;
        isolation: isolate;
      }

      /* High-performance animations */
      @keyframes rotate {
        to { transform: rotate(360deg) translate3d(0, 0, 0); }
      }

      /* Performance optimizations */
      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
        transform: translate3d(0, 0, 0);
        -webkit-transform: translate3d(0, 0, 0);
        backface-visibility: hidden;
        -webkit-backface-visibility: hidden;
        contain: layout style paint;
        isolation: isolate;
      }

      /* High-performance animations */
      @keyframes float {
        0%, 100% { transform: translate3d(0, 0, 0); }
        50% { transform: translate3d(0, -5px, 0); }
      }

      @keyframes glow {
        0%, 100% { 
          filter: brightness(1) blur(10px);
          opacity: 0.5;
        }
        50% { 
          filter: brightness(1.1) blur(8px);
          opacity: 0.6;
        }
      }

      /* Optimized animations */
      .animate-float {
        animation: float 4s ease-in-out infinite;
        will-change: transform;
        transform: translate3d(0, 0, 0);
        -webkit-transform: translate3d(0, 0, 0);
        backface-visibility: hidden;
        -webkit-backface-visibility: hidden;
        contain: layout style paint;
        isolation: isolate;
      }

      .animate-glow {
        animation: glow 3s ease-in-out infinite;
        will-change: filter, opacity;
        transform: translate3d(0, 0, 0);
        -webkit-transform: translate3d(0, 0, 0);
        backface-visibility: hidden;
        -webkit-backface-visibility: hidden;
        contain: layout style paint;
        isolation: isolate;
      }

      /* High-performance gradient orbs */
      .gradient-orb {
        position: absolute;
        border-radius: 50%;
        filter: blur(10px);
        opacity: 0.5;
        mix-blend-mode: soft-light;
        animation: glow 4s ease-in-out infinite;
        pointer-events: none;
        will-change: filter, opacity;
        transform: translate3d(0, 0, 0);
        -webkit-transform: translate3d(0, 0, 0);
        backface-visibility: hidden;
        -webkit-backface-visibility: hidden;
        contain: layout style paint;
        isolation: isolate;
      }

      /* High-performance transitions */
      button, a {
        transition: transform 0.1s ease-out;
        position: relative;
        overflow: hidden;
        will-change: transform;
        transform: translate3d(0, 0, 0);
        -webkit-transform: translate3d(0, 0, 0);
        backface-visibility: hidden;
        -webkit-backface-visibility: hidden;
        contain: layout style paint;
        isolation: isolate;
      }

      /* High-performance image loading */
      img {
        content-visibility: auto;
        border-radius: 8px;
        transition: transform 0.1s ease-out;
        will-change: transform;
        transform: translate3d(0, 0, 0);
        -webkit-transform: translate3d(0, 0, 0);
        backface-visibility: hidden;
        -webkit-backface-visibility: hidden;
        contain: layout style paint;
        isolation: isolate;
      }

      /* High-performance content layout */
      .content {
        min-height: 100vh;
        margin: 0 auto;
        max-width: 1440px;
        padding: 0 24px;
        position: relative;
        z-index: 1;
        will-change: transform;
        transform: translate3d(0, 0, 0);
        -webkit-transform: translate3d(0, 0, 0);
        backface-visibility: hidden;
        -webkit-backface-visibility: hidden;
        contain: layout style paint;
        isolation: isolate;
      }

      /* High-performance card hover effects */
      .hover-card {
        transition: transform 0.1s ease-out, box-shadow 0.1s ease-out;
        will-change: transform, box-shadow;
        transform: translate3d(0, 0, 0);
        -webkit-transform: translate3d(0, 0, 0);
        backface-visibility: hidden;
        -webkit-backface-visibility: hidden;
        contain: layout style paint;
        isolation: isolate;
      }

      /* High-performance animations */
      @keyframes fadeInUp {
        to {
          opacity: 1;
          transform: translate3d(0, 0, 0);
        }
      }

      /* Performance optimizations for reduced motion */
      @media (prefers-reduced-motion: reduce) {
        * {
          animation: none !important;
          transition: none !important;
        }
      }

      /* High-performance mobile optimizations */
      @media (max-width: 768px) {
        .animate-float,
        .animate-glow,
        .gradient-orb {
          animation: none;
        }
        
        .gradient-orb {
          filter: blur(5px);
        }
      }

      /* Maximum performance for low-end devices */
      @media (max-width: 480px) {
        * {
          animation: none !important;
          transition: none !important;
        }
        
        .gradient-orb {
          display: none;
        }
      }
    </style>
    <script type="module" crossorigin src="/assets/index-B4YJ6P8y.js"></script>
    <link rel="stylesheet" crossorigin href="/assets/index-CW5ppEAT.css">
  </head>

  <body>
    <!-- Loading animation -->
    <div class="loading">
      <div class="loader"></div>
    </div>

    <div id="root"></div>

    <!-- Optimized script loading with crossorigin attribute -->
    <script src="https://cdn.gpteng.co/gptengineer.js" type="module" defer crossorigin="anonymous" fetchpriority="high"></script>

    <!-- Optimized Performance monitoring and loading handling -->
    <script>
      // High-performance debounce using requestAnimationFrame
      const debounce = (func, wait) => {
        let timeout;
        return (...args) => {
          cancelAnimationFrame(timeout);
          timeout = requestAnimationFrame(() => {
            clearTimeout(timeout);
            func(...args);
          });
        };
      };

      // High-performance throttle using requestAnimationFrame
      const throttle = (func, limit) => {
        let inThrottle;
        return (...args) => {
          if (!inThrottle) {
            requestAnimationFrame(() => {
              func(...args);
              inThrottle = true;
              setTimeout(() => inThrottle = false, limit);
            });
          }
        };
      };

      // High-performance monitoring
      const performanceMonitor = debounce(() => {
        if (window.performance) {
          const observer = new PerformanceObserver((list) => {
            requestAnimationFrame(() => {
              list.getEntries().forEach((entry) => {
                if (entry.entryType === 'largest-contentful-paint') {
                  console.log(`LCP: ${entry.startTime}ms`);
                }
              });
            });
          });
          observer.observe({ entryTypes: ['largest-contentful-paint'] });
        }
      }, 1000);

      // Schedule tasks using requestAnimationFrame
      const scheduleTask = (task) => {
        if ('requestIdleCallback' in window) {
          requestIdleCallback(() => {
            requestAnimationFrame(task);
          }, { timeout: 1000 });
        } else {
          requestAnimationFrame(() => {
            setTimeout(task, 0);
          });
        }
      };

      scheduleTask(performanceMonitor);

      // High-performance loading screen handling
      const handleLoadingScreen = debounce(() => {
        const loadingScreen = document.querySelector('.loading');
        if (loadingScreen) {
          requestAnimationFrame(() => {
            loadingScreen.style.opacity = '0';
            requestAnimationFrame(() => {
              loadingScreen.style.display = 'none';
              document.body.style.overflow = 'auto';
            });
          });
        }
      }, 0);

      document.addEventListener('DOMContentLoaded', handleLoadingScreen);

      // High-performance page load measurement
      const measureLoadTime = debounce(() => {
        requestAnimationFrame(() => {
          if (window.performance && window.performance.timing) {
            const timing = window.performance.timing;
            const loadTime = timing.loadEventEnd - timing.navigationStart;
            console.log(`Page load time: ${loadTime}ms`);
          } else if (window.performance) {
            const perfData = window.performance.getEntriesByType('navigation')[0];
            if (perfData) {
              console.log(`Page load time: ${perfData.loadEventEnd}ms`);
            }
          }
        });
      }, 1000);

      window.addEventListener('load', measureLoadTime);

      // High-performance scroll handling
      let lastScrollY = window.scrollY;
      let ticking = false;

      const handleScroll = () => {
        lastScrollY = window.scrollY;
        if (!ticking) {
          requestAnimationFrame(() => {
            // Handle scroll events here
            ticking = false;
          });
          ticking = true;
        }
      };

      window.addEventListener('scroll', handleScroll, { passive: true });

      // High-performance resize handling
      let lastWidth = window.innerWidth;
      let lastHeight = window.innerHeight;
      let resizeTimeout;

      const handleResize = () => {
        if (window.innerWidth !== lastWidth || window.innerHeight !== lastHeight) {
          lastWidth = window.innerWidth;
          lastHeight = window.innerHeight;
          requestAnimationFrame(() => {
            // Handle resize events here
          });
        }
      };

      window.addEventListener('resize', handleResize, { passive: true });

      // High-performance cleanup
      const cleanup = () => {
        cancelAnimationFrame(resizeTimeout);
        window.removeEventListener('scroll', handleScroll);
        window.removeEventListener('resize', handleResize);
        window.removeEventListener('load', measureLoadTime);
        document.removeEventListener('DOMContentLoaded', handleLoadingScreen);
      };

      window.addEventListener('unload', cleanup);
      window.addEventListener('beforeunload', cleanup);

      // High-performance memory optimization
      const optimizeMemory = () => {
        requestAnimationFrame(() => {
          if (window.performance && window.performance.memory) {
            const memory = window.performance.memory;
            if (memory.usedJSHeapSize > memory.jsHeapSizeLimit * 0.8) {
              console.log('High memory usage detected, optimizing...');
              if (window.gc) {
                window.gc();
              }
            }
          }
        });
      };

      // Monitor memory usage with requestAnimationFrame
      const monitorMemory = () => {
        requestAnimationFrame(() => {
          optimizeMemory();
          setTimeout(monitorMemory, 30000);
        });
      };

      monitorMemory();
    </script>
  </body>
</html>
